/* Copyright (c) 2023 The University of Sheffield
 *
 * This file is part of StateChum
 *
 * StateChum is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * StateChum is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with StateChum.  If not, see <http://www.gnu.org/licenses/>.
 */
package statechum.analysis.Erlang;

import org.junit.*;
import statechum.Configuration;
import statechum.GlobalConfiguration;
import statechum.analysis.Erlang.Signatures.TestTypes;
import statechum.analysis.learning.experiments.ExperimentRunner;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.Arrays;

public class TestErlangModuleMaps {
    /** This one is used to number work directories so that different tests do not affect each other. Unfortunately, the numbering is sequential hence it is not known which test corresponds to which number. */
    protected static int number = 0;

    /** URL of the writable directory to be used for tests. */
    public File testDir = null;

    public static final String ErlangExamples = GlobalConfiguration.getConfiguration().getProperty(GlobalConfiguration.G_PROPERTIES.PATH_ERLANGEXAMPLES);
    protected Configuration config = Configuration.getDefaultConfiguration().copy();
    protected ErlangRunner runner = null;
    protected static ErlangRuntime erlRuntime;

    /** The name of test file - should not be static to ensure it picks the value of TestErlangRunner's variable
     * after it has been initialised.
     */
    protected String erlangFile = null, erlangFileOther = null;

    public TestErlangModuleMaps()
    {
    }

    @BeforeClass
    public static void beforeClass()
    {
        // Switching versions of Erlang causes problems when an older .beam or older .plt are seen by the newer version of Erlang.
        // In a similar way, I cannot expect files generated by the newer version to be readable by the old one.
        // We start by deleting all these files are re-build them.
        for(String erlSource: Arrays.asList("locker/locker.erl","WibbleMonster/wibble.erl","exporter/exporter.erl","frequency/frequencyBroken.erl","frequency/frequencyFixed.erl","frequency/frequency.erl")) {
            Configuration configErl = Configuration.getDefaultConfiguration().copy();
            ErlangModule.setupErlangConfiguration(configErl,new File(ErlangExamples,erlSource));

            //noinspection ResultOfMethodCallIgnored
            new File(ErlangRunner.getName(configErl.getErlangSourceFile(), ErlangRunner.ERL.PLT,configErl.getErlangCompileIntoBeamDirectory())).delete();
            //noinspection ResultOfMethodCallIgnored
            new File(ErlangRunner.getName(configErl.getErlangSourceFile(), ErlangRunner.ERL.BEAM,configErl.getErlangCompileIntoBeamDirectory())).delete();
        }

        erlRuntime = new ErlangRuntime();erlRuntime.setTimeout(500);erlRuntime.startRunner();
    }

    @AfterClass
    public static void afterClass()
    {
        erlRuntime.killErlang();
    }

    @Before
    public void beforeTest()
    {
        testDir = new File(GlobalConfiguration.getConfiguration().getProperty(GlobalConfiguration.G_PROPERTIES.TEMP),"__TestErlangRunner__"+(number++));
        runner = erlRuntime.createNewRunner();config.setErlangMboxName(runner.getRunnerName());
        erlangFile=testDir.getAbsolutePath()+File.separator+"testFile.erl";
        erlangFileOther = testDir.getAbsolutePath()+File.separator+"testFileOther.erl";
        ErlangModule.flushRegistry();
        if (!testDir.isDirectory())
        {
            Assert.assertTrue("could not create "+testDir.getAbsolutePath(),testDir.mkdir());
        }
    }

    @After
    public void afterTest()
    {
        runner.close();
        ExperimentRunner.zapDir(testDir);
    }

    @Test
    public void testLoadExports3() throws IOException
    {
        final String someErlang = "-module(testFile).\n-export([testFun/1]).\ntestFun(3)->#{4 => 5}.";
        Writer wr = new FileWriter(erlangFile);wr.write(someErlang);wr.close();
        ErlangModule.setupErlangConfiguration(config,new File(erlangFile));
        ErlangModule mod = ErlangModule.loadModule(config);
        Assert.assertEquals("[{"+ErlangLabel.missingFunction+",'testFile:testFun/1',[3],#{4 => 5}}"+
                        "]"
                ,TestTypes.getAlphabetAsString(mod ));
    }
    @Test
    public void testLoadExports4() throws IOException
    {
        final String someErlang = "-module(testFile).\n-export([testFun/1]).\ntestFun(3)->#{4 => 5};\ntestFun(4)->#{6 => 6}.";
        Writer wr = new FileWriter(erlangFile);wr.write(someErlang);wr.close();
        ErlangModule.setupErlangConfiguration(config,new File(erlangFile));
        ErlangModule mod = ErlangModule.loadModule(config);
        Assert.assertEquals("[{"+ErlangLabel.missingFunction+",'testFile:testFun/1',[3],#{4 => 5,6 => 6}}," +
                        "{"+ErlangLabel.missingFunction+",'testFile:testFun/1',[3],#{}}" +// this is technically incorrect but cannot be made correct due to the abstraction of the data types by typer.
                        "]"
                ,TestTypes.getAlphabetAsString(mod ));
    }

    @Test
    public void testLoadExports5() throws IOException
    {
        final String someErlang = "-module(testFile).\n-export([testFun/1]).\ntestFun(3)->#{4 => 5};\ntestFun(4)->#{4 => 6}.";
        Writer wr = new FileWriter(erlangFile);wr.write(someErlang);wr.close();
        ErlangModule.setupErlangConfiguration(config,new File(erlangFile));
        ErlangModule mod = ErlangModule.loadModule(config);
        Assert.assertEquals("[{"+ErlangLabel.missingFunction+",'testFile:testFun/1',[3],#{4 => 5}}" + // instantiate all pairs picks one of the values from a set of values hence we only get one pair.
                        "]"
                , TestTypes.getAlphabetAsString(mod ));
    }

    @Test
    public void testLoadExports6() throws IOException
    {
        final String someErlang = "-module(testFile).\n-export([testFun/1]).\ntestFun(3)->#{4 => 5, 6 =>8};\ntestFun(4)->#{6 => 1}.";
        Writer wr = new FileWriter(erlangFile);wr.write(someErlang);wr.close();
        ErlangModule.setupErlangConfiguration(config,new File(erlangFile));
        ErlangModule mod = ErlangModule.loadModule(config);
        Assert.assertEquals("[{"+ErlangLabel.missingFunction+",'testFile:testFun/1',[3],#{6 => 1,4 => 5}}," +
                        "{"+ErlangLabel.missingFunction+",'testFile:testFun/1',[3],#{6 => 1}}" +// 6 is a mandatory key hence always present and 4 is an optional one hence not always present.
                        "]"
                ,TestTypes.getAlphabetAsString(mod ));
    }

    @Test
    public void testLoadExports7() throws IOException
    {
        final String someErlang = "-module(testFile).\n-export([testFun/1]).\ntestFun(3)->#{}.";
        Writer wr = new FileWriter(erlangFile);wr.write(someErlang);wr.close();
        ErlangModule.setupErlangConfiguration(config,new File(erlangFile));
        ErlangModule mod = ErlangModule.loadModule(config);
        Assert.assertEquals("[{"+ErlangLabel.missingFunction+",'testFile:testFun/1',[3],#{}}" +
                        "]"
                ,TestTypes.getAlphabetAsString(mod ));
    }

    @Test
    public void testLoadExports8() throws IOException
    {
        final String someErlang = "-module(testFile).\n-export([testFun/1]).\ntestFun(3)->#{4 => 5};\ntestFun(Arg) ->#{4 => 8,Arg => 6}.";
        Writer wr = new FileWriter(erlangFile);wr.write(someErlang);wr.close();
        ErlangModule.setupErlangConfiguration(config,new File(erlangFile));
        ErlangModule mod = ErlangModule.loadModule(config);
        Assert.assertEquals(
                // here Arg has Any type and value is 6.
                "[{"+ErlangLabel.missingFunction+",'testFile:testFun/1',['JustAnythingA'],#{4 => 5,'JustAnythingA' => 6}}," +
                        "{"+ErlangLabel.missingFunction+",'testFile:testFun/1',['JustAnythingA'],#{4 => 5,[] => 6}}," +
                        "{"+ErlangLabel.missingFunction+",'testFile:testFun/1',['JustAnythingA'],#{4 => 5,['WibbleA'] => 6}}," +
                        "{"+ErlangLabel.missingFunction+",'testFile:testFun/1',['JustAnythingA'],#{4 => 5,['WibbleA','WobbleA'] => 6}}," +
                        "{"+ErlangLabel.missingFunction+",'testFile:testFun/1',[[]],#{4 => 5,'JustAnythingA' => 6}}," +
                        "{"+ErlangLabel.missingFunction+",'testFile:testFun/1',[[]],#{4 => 5,[] => 6}}," +
                        "{"+ErlangLabel.missingFunction+",'testFile:testFun/1',[[]],#{4 => 5,['WibbleA'] => 6}}," +
                        "{"+ErlangLabel.missingFunction+",'testFile:testFun/1',[[]],#{4 => 5,['WibbleA','WobbleA'] => 6}}," +
                        "{"+ErlangLabel.missingFunction+",'testFile:testFun/1',[['WibbleA']],#{4 => 5,'JustAnythingA' => 6}}," +
                        "{"+ErlangLabel.missingFunction+",'testFile:testFun/1',[['WibbleA']],#{4 => 5,[] => 6}}," +
                        "{"+ErlangLabel.missingFunction+",'testFile:testFun/1',[['WibbleA']],#{4 => 5,['WibbleA'] => 6}}," +
                        "{"+ErlangLabel.missingFunction+",'testFile:testFun/1',[['WibbleA']],#{4 => 5,['WibbleA','WobbleA'] => 6}}," +
                        "{"+ErlangLabel.missingFunction+",'testFile:testFun/1',[['WibbleA','WobbleA']],#{4 => 5,'JustAnythingA' => 6}}," +
                        "{"+ErlangLabel.missingFunction+",'testFile:testFun/1',[['WibbleA','WobbleA']],#{4 => 5,[] => 6}}," +
                        "{"+ErlangLabel.missingFunction+",'testFile:testFun/1',[['WibbleA','WobbleA']],#{4 => 5,['WibbleA'] => 6}}," +
                        "{"+ErlangLabel.missingFunction+",'testFile:testFun/1',[['WibbleA','WobbleA']],#{4 => 5,['WibbleA','WobbleA'] => 6}}]"
                ,TestTypes.getAlphabetAsString(mod ));
    }

}